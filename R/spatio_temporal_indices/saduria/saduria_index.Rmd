---
title: "Saduria index standardization"
author: "Max Lindmark"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
  df_print: paged
pdf_document: default
editor_options: 
  chunk_output_type: console
---
  
```{r setup, include = FALSE, cache=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 12,
  fig.asp = 0.618,
  fig.align ='center'
)
```

# Fit a spatiotemporal model to Saduria data for index standardization

## First read in and clean data
```{r libraries, message=FALSE}
# Load libraries, install if needed
library(tidyverse); theme_set(theme_classic())
library(readxl)
library(tidylog)
library(RCurl)
library(sp)
library(geosphere)
library(viridis)
library(RColorBrewer)
library(patchwork)
library(janitor)
library(icesDatras)
library(mapdata)
library(patchwork)
library(rgdal)
library(raster)
library(sf)
library(rgeos)
library(chron)
library(lattice)
library(ncdf4)
library(sdmTMB) # remotes::install_github("pbs-assess/sdmTMB")
library(marmap)
library(rnaturalearth)
library(rnaturalearthdata)
library(mapplots)
library(qwraps2) # To load entire cache in interactive r session, do: qwraps2::lazyload_cache_dir(path = "saduria_index_cache/html")

# For adding maps to plots
world <- ne_countries(scale = "medium", returnclass = "sf")

# Specify map ranges
# ymin = 54; ymax = 58; xmin = 9.5; xmax = 22
ymin = 54; ymax = 58; xmin = 12.5; xmax = 22

# Make plot function
plot_map_raster <- function(dat, column = "est") {
  ggplot(dat, aes_string("X", "Y", fill = column)) +
    geom_raster() +
    facet_wrap(~year) +
    coord_fixed() +
    scale_fill_viridis_c() +
    geom_sf(data = world, inherit.aes = F, size = 0.2) +
    coord_sf(xlim = c(xmin, xmax), ylim = c(ymin, ymax))
}
```

## Fit models using `sdmTMB`
Fit a biomass model assuming a Tweedie distribution and biomass as the response.

```{r fit tweedie model, cache=TRUE}
# In the samples we have depth, is there are relation between biomass and depth?
# If so, we might want to use depth from another source
sad %>% 
  filter(biomass > 0) %>% 
  ggplot(., aes(depth, biomass)) +
  geom_point() + 
  stat_smooth()

ggplot(sad, aes(depth, abundance)) +
  geom_point() +
  stat_smooth()

sad_biom <- sad %>% drop_na(biomass)

# Make it a density (g per m^2)
sad_biom <- sad_biom %>% mutate(biomass_g_m2 = biomass/0.1)

# Convert to g/km^2
sad_biom <- sad_biom %>% mutate(biomass_g_km2 = biomass_g_m2*1000000)

# Convert to kg/km^2
sad_biom <- sad_biom %>% mutate(biomass_kg_km2 = biomass_g_km2/1000)

sad_biom <- sad_biom %>% mutate(biomass = biomass_g_m2)

# First define the SPDE mesh:
spde_biom <- make_mesh(data = sad_biom, xy_cols = c("lon", "lat"), n_knots = 400, type = "kmeans", seed = 42)

plot(spde_biom)

m_tweed <- sdmTMB(formula = biomass ~ as.factor(year) - 1, data = sad_biom,
                  time = "year", spde = spde_biom, family = tweedie(link = "log"),
                  ar1_fields = TRUE, include_spatial = FALSE, spatial_trend = FALSE, spatial_only = FALSE,
                  newton_steps = 1)

# Check residuals
d_biom <- sad_biom
d_biom$residuals <- residuals(m_tweed)

# Pretty good!
qqnorm(d_biom$residuals, xlim = c(-5, 5), ylim = c(-5, 5)); abline(a = 0, b = 1)

# We can also inspect randomized quantile residuals::
hist(d_biom$residuals)

# Lastly, plot residuals on a map
ggplot(d_biom, aes(lon, lat, colour = residuals)) +
  geom_point(size = 0.5) +
  facet_wrap(~year, ncol = 5) +
  scale_color_gradient2()
```

Make prediction onto the new grid:
```{r predict on grid, message=FALSE}
# Predict using the Tweedie model
preds_simple <- predict(m_tweed, newdata = pred_grid)

# Replace non-valid grids with NA (too long from shoreline)
preds_simple <- preds_simple %>% mutate(est2 = ifelse(valid_pred == "N", NA, est), # prediction (fixed + random)
                                        eps_st2 = ifelse(valid_pred == "N", NA, epsilon_st), # spatiotemporal effects
                                        est_non_rf2 = ifelse(valid_pred == "N", NA, est_non_rf)) # fixed effects

# Plot predictions!
preds_simple %>% 
  ggplot(., aes(lon, lat, fill = est2)) +
  geom_raster() +
  facet_wrap(~year, ncol = 8) +
  scale_fill_viridis(option = "magma", na.value = "transparent") + 
  #geom_sf(data = world, inherit.aes = F, size = 0.2) +
  #coord_sf(xlim = c(xmin, xmax), ylim = c(ymin, ymax)) + 
  ggtitle("Prediction (random + fixed)")

# Plot predictions for few years
preds_simple %>% 
  filter(year %in% c(1985, 2018)) %>% 
  ggplot(., aes(lon, lat, fill = est2)) +
  geom_raster() +
  facet_wrap(~year, ncol = 2) +
  scale_fill_viridis(option = "magma", na.value = "transparent") + 
  #geom_sf(data = world, inherit.aes = F, size = 0.2) +
  #coord_sf(xlim = c(xmin, xmax), ylim = c(ymin, ymax)) + 
  ggtitle("Prediction (random + fixed)")

# Plot spatiotemporal random effects
preds_simple %>% 
  ggplot(., aes(lon, lat, fill = eps_st2)) +
  geom_raster() +
  facet_wrap(~year, ncol = 8) +
  scale_fill_gradient2(na.value = "transparent") +
  #geom_sf(data = world, inherit.aes = F, size = 0.2) +
  #coord_sf(xlim = c(xmin, xmax), ylim = c(ymin, ymax)) + 
  ggtitle("Prediction (random + fixed)")
```

Now calculate the index:

```{r calculate index, cache=TRUE, message=FALSE}
# Now predict using the index standardization 
pred_grid_index <- pred_grid %>% filter(valid_pred == "Y")
preds <- predict(m_tweed, newdata = pred_grid_index, return_tmb_object = TRUE)

# Not bias correcting for vignette-building speed:
ind <- get_index(preds, bias_correct = FALSE)

# Estimate centre of gravity
# cog <- get_cog(preds, bias_correct = FALSE)
# 
# cog %>% 
#   mutate(coord = ifelse(est > 30, "lat", "lon")) %>% 
#   ggplot(., aes(year, est)) +
#   geom_point() +
#   facet_wrap(~ coord, scales = "free") + 
#   geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.4)

# https://www.nhc.noaa.gov/gccalc.shtml
# Distance from 55.1, 13 to 55.15,13 is 6 km
# Distance from 55.1, 13 to 55.1,13.05 is 3 km
# Hence, the area of a grid is 6*3 = 18 km2

# Scale the biomass by the area and adjust units
scale <- (6*3)/1000 # 6 x 3 km pred grid and from kg to tonnes

ggplot(ind, aes(year, est*scale)) + geom_line() +
  geom_ribbon(aes(ymin = lwr*scale, ymax = upr*scale), alpha = 0.4) +
  xlab('Year') + ylab('Biomass estimate (tonnes)') +
  theme_classic(base_size = 20)

# Checking it makes sense...
# How much does a saduria weigh on average?
sad_biom %>% filter(abundance == 1) %>% summarise(mean_weight = mean(biomass))
# 0.3 g - fix this calculation!

# How many grid cells are there?
pred_grid_index %>% group_by(year) %>% mutate(n = n()) %>% ungroup() %>% distinct(n)
# 2095 grid cells

# I'm predicting there are on average.... 
# mean(ind$est) * (6*3)/1000 = 83986.36 tonnes saduria in the survey domain

# The survey domain is 2095 cells each with an area of 18km^2
# That gives a total area of 2095*18 = 37710 km^2

# So I have 83986.36 tonnes / 37710 km^2

# That is 2.22 tonnes per km^2

# Or 2220 kg/km^2

# Or 2220*0.001=2.22 g/m^2 # https://www.google.com/search?sxsrf=ALeKk00fJjuA33hOBYF119g2RYY5y7NQhg%3A1608536162203&source=hp&ei=YlDgX-qwCcSblwT-852ABw&q=g%2Fm2+to+kg%2Fkm2&oq=g%2Fm2+to+kg%2Fkm2&gs_lcp=CgZwc3ktYWIQAzIFCAAQyQNQhwJYhwJg5gNoAHAAeACAAVqIAVqSAQExmAEAoAECoAEBqgEHZ3dzLXdpeg&sclient=psy-ab&ved=0ahUKEwjq6baUyN7tAhXEzYUKHf55B3AQ4dUDCAY&uact=5

# A saduria weighs 0.309 g. That means I expect on average:
# 2.22/0.309 = 7 saduria per m^2

# What is the average abundance in the data?
sad_biom %>%
  mutate(abund_per_m2 = abundance / 0.1) %>%
  summarise(mean_abundance_density = mean(abund_per_m2))

# Could make sense...

# How many 
hist(sad_biom$biomass_kg_km2)
```

```{r test}
sad_biom %>% 
  group_by(year) %>% 
  summarise(mean_biom = mean(biomass_g_m2)) %>% 
  ggplot(., aes(year, mean_biom)) + 
  geom_point() + 
  stat_smooth() +
  theme_classic(base_size = 20)
  NULL

sad %>% 
  group_by(year) %>% 
  summarise(mean_abun = mean(abundance)) %>% 
  ggplot(., aes(year, mean_abun)) + 
  geom_point(size = 3) + 
  stat_smooth() +
  theme_classic(base_size = 20)
  NULL
```

